# 자료구조

### Array VS Linked List

##### Array

* 가장 기본적인 자료구조로, **논리적 저장 순서와 물리적 저장 순서 일치**

  * 따라서 `index`로 해당 원소에 접근할 수 있고, `index`값을 알고 있다면 O(1)로 원소 접근 가능
  * **random access** 방식 사용
    * 메모리의 어드레스만 지시하면 어느 부분에서도 즉시 데이터를 읽을 수 있는 호출 방식 

  * 그러나 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 추가 작업을 해줘야 하기 때문에 시간이 더 걸리게 됨
  * 삭제 또는 삽입을 하게 되면, 배열의 연속적인 특징이 깨지게 됨. 삭제 또는 삽입 시 해당 원소보다 큰 인덱스를 가진 원소들을 shift 해줘야 하는 비용 발생(O(n))

  * **탐색 기능의 시간복잡도 O(1)**
  * **삭제/삽입 기능의 시간복잡도 worst case -> O(n)**

##### Linked List

* Array의 문제를 해결하기 위한 자료구조. **논리적 저장 순서와 물리적 저장 순서 불일치**
* 각각의 원소들은 자기 자신 다음에 나오는 원소만을 기억하고 있음. 따라서 이 부분만 바꿔주면삭제와 삽입을 O(1) 만에 해결할 수 있음
* 하지만 원하는 위치에 삭제/삽입을 하고자 하면 원하는 위치를 탐색하는 과정에 있어서 첫번째 원소부터 다 확인해봐야 함.
* 따라서, 삭제/삽입을 하고자 할 때, 위치를 찾는 과정에서 O(n)의 시간이 추가적으로 발생
* **탐색 기능의 시간복잡도 O(n)**
* **삭제/삽입 기능의 시간복잡도 worst case -> O(n)**
* 그러나 `Tree` 구조의 근간이 되는 자료구조로, `Tree`에서 사용 시 유용성을 지님



그러므로 데이터의 접근/탐색이 중요하다면 Array를, 삭제/삽입이 중요하다면 Linked List

---

### Stack and Queue

##### Stack(스택)

* 선형 자료구조

* `LIFO` - Last In First Out, 나중에 들어간 원소가 먼저 나오는 구조

* 사용사례

  * 재귀 알고리즘 사용에 유용
  * 웹 브라우저 방문 기록
  * 역순 문자열 만들기

  

##### Queue(큐)

* 선형 자료구조
* `FIFO` - First in First Out, 먼저 들어간 원소가 먼저 나오는 구조
* 사용사례
  * BFS(너비 우선 탐색)
  * 캐시 구현
  * 선입선출이 필요한 대기열

---

#### Tree

* 비선형 자료구조, 계층적 관계를 표현하는 구조

* **용어**

  * `Node`(노드) : 트리를 구성하고 있는 각각의 요소
  * `Edge`(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미
  * `Root Node`(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미
  * `Terminal Node`(= `Leaf Node`, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미
  * `Internal Node`(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 **루트 노드 포함**
  * `Size`(크기) : 자신을 포함한 모든 자손 노드의 개수
  * `depth`(깊이) : 루트에서 특정 노드에 도달하기까지 거쳐야 하는 간선의 개수
  * `level`(레벨) : 트리의 특정 깊이를 가지는 노드의 집합, 루트 노드부터 1로 시작
    * `level` = `depth` + 1
  * `degree`(차수) : 해당 노드의 간선 수
  * `degree of tree`(트리의 차수) : 트리의 **최대 차수**
  * `height`(높이) : 루트 노드에서 가장 깊숙히 있는 노드의 `depth`, 트리 중 가장 긴 경로의 간선 개수 

  

##### Binary Tree (이진 트리)

* 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 지고, 두 서브 트리 또한 모두 이진 트리여야 함
* 공집합 역시도 이진 트리
* 노드가 하나뿐인 것도 이진 트리에 해당
* **종류**
  * **Perfect Binary Tree (포화 이진 트리)**
    * 모든 단말 노드의 깊이가 같은 완전 이진 트리
    * `height`가 n이라면 포화 이진 트리의 노드 개수는 **2^n - 1개**
  * **Complete Binary Tree (완전 이진 트리)**
    * 마지막 레벨을 제외하고 모든 노드가 채워진 이진 트리
    * 마지막 레벨의 노드들은 왼쪽부터 채워짐
    * `height`가 n인 완전 이진 트리의 노드 개수(m)는 **2^(n-1) <= m <= 2^n - 1개**



##### Binary Search Tree (이진 탐색 트리)

* 이진 탐색과 연결리스트를 결합한 자료구조의 일종
* 이진 탐색의 탐색 시간 복잡도는 O(logn)이지만 삽입/삭제 불가능
* 연결리스트는 삽입/삭제에 시간 복잡도 O(1)로 효율적(최악의 경우 O(n))이지만 탐색하는 데 O(n) 소요
* **규칙**
  * 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 구성
  * 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 구성
  * 중복된 노드가 없어야 함
  * 왼쪽 서브트리, 오른쪽 서브트리 역시 이진 탐색 트리
* 이진 탐색 트리를 순회할 때는 **중위 순회** 사용
* 추가 데이터 삽입 시 단말 노드에 삽입
* 이진 탐색 트리의 탐색 연산은 O(logn)의 시간 복잡도를 가짐. 그러나, 엄밀히 얘기하면 트리의 높이를 하나씩 더해갈 수록 추가할 수 있는 노드의 수는 두배씩 증가하므로 O(h)라고 표현하는 것이 맞음
* 저장 순서가 계속 한 쪽으로만 추가될 경우 `Skewed Tree`(편향 트리)가 되면서 성능에 영향을 미칠 수 있고, 최악의 경우 탐색에 있어 시간 복잡도는 O(n)이 되는 경우도 생김
  * 이 경우, Array보다 많은 메모리를 사용하여 데이터를 저장했지만 필요한 시간 복잡도가 같게 되는 비효율이 발생 -> 이를 해결하기 위해 `Rebalancing` 기법 등장
    * `Rebalancing` : 균형을 잡기 위한 트리 구조의 재조정
  * 그 중 하나가 바로 `Red-Black Tree`



##### Binary Heap (이진 힙)

---

* `Tree`의 형식을 하고 있으며, 트리 중에서도 배열에 기반한 **완전 이진 트리**

* 최댓값과 최솟값 찾기 연산을 빠르게 하기 위해 고안된 **완전 이진 트리**
* **속성**
  * A가 B의 부모노드라면 A의 값과 B의 값 사이에는 대소관계가 성립
  * 형제 사이에는 대소관계가 정해지지 않음
* **종류**
  * 최대 힙 : 부모노드의 값이 자식노드의 값보다 항상 큰 힙
  * 최소 힙 : 부모노드의 값이 자식노드의 값보다 항상 작은 힙
* 최대 힙/최소 힙에서 최댓값/최솟값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)
* 최대 힙/최소 힙을 만드는 과정에서 최악의 경우 루트 노드에서 단말 노드까지 내려가는 케이스가 발생할 수 있음. 이 때의 시간 복잡도는 O(logn)

* 힙 정렬의 시간 복잡도는 O(nlogn)
* 힙 생성 과정 및 정렬 [참고 블로그](https://zeddios.tistory.com/56)